\input texinfo    @c -*-texinfo-*-
%
% fmcadc100m14b4cha_firmware_manual.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make fmcadc100m14b4cha_firmware_manual.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@documentencoding UTF-8
@setfilename fmcadc100m14b4cha_firmware_manual.info
@settitle fmcadc100m14b4cha_firmware_manual
@iftex
@afourpaper
@end iftex
@c @paragraphindent 0
@comment %**end of header

@setchapternewpage off

@set update-month August 2020

@finalout

@titlepage
@title FmcAdc100m14b4cha Gateware Guide
@subtitle @value{update-month} - Release 5.0
@subtitle For AFC FMC Carrier
@image{../fig/ohr_logo,4cm,,,pdf}
@sp 10
@flushright
@image{../fig/cern_logo,3cm,,,pdf}
@end flushright
@author Matthieu Cattin (CERN)
@author Dimitrios Lampridis (CERN)
@author Lucas Russo (LNLS)
@end titlepage
@headings single

@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

This document describes the gateware developed to support the FmcAdc100m14b4cha (later refered to as fmc-adc) mezzanine card on the AFCC@footnote{@uref{ihttps://ohwr.org/project/afc}} carrier card.
The gateware is the HDL code used to generate the bitstream that configures the FPGA on the carrier (sometimes also called firmware).
The gateware architecture is described in detail.
The configuration and operation of the fmc-adc is also explained.
On the other hand, this manual is not intended to provide information about the software used to control the fmc-adc board, nor details about it's hardware design.

@c ##########################################################################
@node Repositories and Releases
@chapter Repositories and Releases

This project is hosted on Github, but hopefully soon-to-be-merged into the upstream
project on the Open Hardware Repository (@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-gw}),
at the following link:@*
@uref{https://github.com/lnls-dig/fmc-adc-100m14b4cha-gw/tree/afcv3-port}


Here a list of resources that you can find on the project page.
@table @code

@item Documents@footnote{@uref{https://github.com/lnls-dig/fmc-adc-100m14b4cha-gw/releases}}
contains the @t{.bit} FPGA binary files and the @t{.pdf} documentation for every official release.

@item Repository@footnote{@uref{https://github.com/lnls-dig/fmc-adc-100m14b4cha-gw}}
contains the git repository of the project.

@end table

On the repository the official releases have a tag named
@code{afc-fmc-adc-v#maj.#min} where @code{#maj} represent the major release
version of the gateware and @code{#min} the minor one (e.g @code{afc-fmc-adc-v5.0}).
The released FPGA binary files follow the same naming convention.

The git commit hash has to be written in the sdb meta-information, therefore a release consists of two commits.
The commit coming right after the tagged one contains the updated sdb meta-information file, the ise project and the synthesis, place&route, timing, and the reports.

@b{Note:} If you got this from the repository (as opposed to a named @i{tar.gz} or @i{pdf} file) it may happen that you are looking at a later commit than the release this manual claims to document.
It is a fact of life that developers forget to re-read and fix documentation while updating the code. In that case, please run ``@code{git describe HEAD}'' to ensure where you are.

@c ==========================================================================
@section Software Support

For information on the userspaces HALCS software support, please refer to the following project:@*
@uref{https://github.com/lnls-dig/halcs}


@c ##########################################################################
@page
@node About source code
@chapter About Source Code

@c ==========================================================================
@section Build from Sources

The fmc-adc hdl design make use of the @command{hdlmake}@footnote{@uref{http://www.ohwr.org/projects/hdl-make}} tool.
It automatically fetches the required hdl cores and libraries. It also generates Makefiles for synthesis/par and simulation.

Here is the procedure to build the FPGA binary image from the hdl source.

@enumerate
@item Install @command{hdlmake} (version 3.0).
@item Get fmc-adc hdl AFC sources while still not in master.@*
      @code{git clone --recursive --branch afcv3-port https://github.com/lnls-dig/fmc-adc-100m14b4cha-gw <src_dir>}
@item Goto the synthesis directory.@*
      @code{cd <src_dir>/hdl/syn/<carrier>}
@item Fetch the dependencies and generate a synthesis Makefile.@*
      @code{hdlmake}
@item Perform version bundling and synthesis, place, route and generate FPGA bitstream.@*
      @code{./build_synthesis_sdb.sh && make}
@item Alternatively you can issue a more complete synthesis command to perform everything at once.@*
      @code{./build_synthesis_sdb.sh && hdlmake -a makefile && time make && date}
@end enumerate

@c TODO explain how to fetch dependencies with git submodules.
@c TODO explain how to build without hdlmake.

@c ==========================================================================
@section Source Code Organisation

@table @file
@item hdl/rtl/
      ADC specific hdl sources.
@item hdl/rtl/wb_gen/
      ADC specific @command{wbgen2} sources, html documentation and C header file.
@item hdl/ip_cores/
      Location of fetched and generated hdl cores and libraries.
@item hdl/syn/<carrier>
      Synthesis directory for selected carrier. This is where the synthesis top manifest and the ISE/Vivado project are stored.
@item hdl/top/<carrier>
      Top directory for selected carrier. This is where the top-level entity is store.
@item hdl/testbench/<module>
      Carrier/Modules related simulation files and testbenches.
@end table

It could happen that a hdl source directory contains extra source files that are not used in the current gateware release.
In order to identify the source files used in a given release, refer to the @file{Manifest.py} files.

@c ==========================================================================
@section Dependencies

The fmc-adc gateware depends on the following hdl cores and libraries:
@table @b
@item general-cores-lnls
      @code{repo  : https://github.com/lnls-dig/general-cores.git}@*
      @code{commit: 200062d6e0c84fc0005efad3618edb32eb440ed9}
@item infra-cores
      @code{repo  : https://github.com/lnls-dig/infra-cores.git}@*
      @code{commit: 14ed99438ace2d523928768d88aa837498df5165}
@item afc-gw
      @code{repo  : https://github.com/lnls-dig/afc-gw.git}@*
      @code{commit: d42f19894a7d8f999bf940863e3cec6320c0832a}
@end table

@c ##########################################################################
@page
@node Architecture
@chapter Architecture

This chapter describes the internal blocks of the FPGA for AFC carrier.
The gateware is designed around one or several Wishbone@footnote{@uref{http://opencores.org/opencores@comma{}wishbone}} bus interconnects.
@c FIXME  broken @comma{} to generate url link (prints 'comma{}' instead of ',')

@c ==========================================================================
@section AFC carrier

In this version of the gateware all blocks (except the memory controller) are connected to the PCIe bridge interface using the same Wishbone bus (@i{main} bus).
The ADC samples are written and read to/from the DDR memory using a direct AXI Stream connection.
Due to its size, the DDR memory is not mapped on the @i{main} Wishbone bus and can be accessed through PIO or DMA from the host.
@ref{fig:afc_fw_arch} illustrates the fmc-adc gateware architecture on the AFC carrier.
A crossbar from the general-cores@footnote{@uref{https://www.github.com/lnls-dig/general-cores}} library is used to map the slaves in the Wishbone address space.

@float Figure,fig:afc_fw_arch
@center @image{../fig/afc_fw_arch, 12cm,,,pdf}
@caption{FMC-ADC gateware architecture on AFC carrier.}
@end float

@sp 1

There is one Wishbone bus interconnect in the design.
@table @b
@item Mapped WB bus (from PCIe interconnect to all slaves)
      This bus connects all the peripherals to the PCIe interconnect core.@*
      Data: 32-bit, address: 32-bit (byte aligned), clock: system clock (125MHz).
@end table


@ref{tab:afc_memory_map} shows the Wishbone slaves mapping and hierarchy.
The first column represents the byte address offset from the start of the Wishbone address space (BAR 4).

@float Table,tab:afc_memory_map
@include afc_wb_tree.txt
@caption{Wishbone bus memory mapping (BAR 4).}
@end float

@sp 1

The Wishbone crossbar also implements SDB@footnote{@uref{http://www.ohwr.org/projects/fpga-config-space}} records. Those records describe the Wishbone slaves and their mapping on the bus.
The SDB records ROM must be located at offset @code{0x0}.
In order to identify the gateware, SDB meta-information records are used.
The 'Integration', 'Top module repository url' and 'Synthesis tool information'  meta-information records are used in the design.
Below is a description of the fields and their content in the fmc-adc design on the AFC carrier.

@table @b
@item Top module repository url
      repo_url = "https://github.com/lnls-dig/fmc-adc-100m14b4cha-gw"@*
@item Synthesis tool information
      syn_module_name  = "afc_ref_design"@*
      syn_commit_id    = git log -1 --format="%H" | cut -c1-32 @*
      syn_tool_name    = "VIVADO"@*
      syn_tool_version = bcd encoded synthesis tool version@*
      syn_date         = bcd encoded synthesis date, format yyyymmdd@*
      syn_username     = username of person who synthesised the design
@end table


All of the Wisbone addressable slaves have a SDB Vendor (VID) and Device (DID) IDs associated
to it, so the software can identify which module is located at that offset. @ref{tab:afc_sdb_ids}
shows the SDB Vendor/Device IDs of the modules used in the design.

@ref{tab:afc_sdb_ids} shows the SDB Vendor/Device IDs of the modules used in the design.

@float Table,tab:afc_sdb_ids
@include afc_sdb_ids_tree.txt
@caption{AFC SDB IDs used in the design.}
@end float

@sp 1


Note that some of the cores from the general-cores library are based on cores from
OpenCores@footnote{@uref{http://opencores.org/}}. Therefore, the documentation for those cores is hosted on the OpenCores website.

@c --------------------------------------------------------------------------
@subsection Clock Domains

The SPEC version of the fmc-adc design has five different clock domains. They are listed in the following table.

@float
@multitable {@code{sys_clk}}{ADC data de-serialiser clock}{125.00 MHz}{400MHz LTC2174 (mezzanine)}
@headitem Name @tab Description @tab Frequency @tab Source
@item @code{sys_clk} @tab Main system clock @tab 100.00 MHz @tab 100MHz VCO (carrier)
@item @code{ddr_clk} @tab DDR interface clock @tab 200.00 MHz @tab 100MHz TCXO (carrier)
@item @code{aux_clk} @tab Trigger MLVDS clock @tab 125.00 MHz @tab 69.44MHz MicroTCA.4 TCLKA (carrier)
@item @code{fs_clk} @tab Sampling clock @tab 100.00 MHz @tab 400MHz LTC2174 (mezzanine)
@item @code{serdes_clk} @tab ADC data de-serialiser clock @tab 800.00 MHz @tab 400MHz LTC2174 (mezzanine)
@item @code{pcie_clk} @tab PCIe clock @tab 125.00 MHz @tab 100MHz PCIe tranceiver MicroTCA.4 FCLKA (carrier)
@end multitable
@end float

@sp 1

@c --------------------------------------------------------------------------
@subsection PCIe Core

This block is the interface between the Xilinx PCIe Integrated Block
@footnote{https://www.xilinx.com/support/documentation/ip_documentation/pcie_7x/v3_3/pg054-7series-pcie.pdf}
to the other blocks in the FPGA, thourgh BAR4,
and to DDR memory, though BAR2. BAR0 is reserved to PCIe Core configuration registers.

Currently, the PCIe core supports four lane PCI Express Generation 1.1, implementing the transaction layers on FPGA logic.
PHY and Data Link layers are taken care by the Xilinx PCIe Integrated Block.
The PCIe core is used to access the FPGA registers, but also to generate INTx/MSI interrupts and DMA transactions.
BAR4 (Base Address Register) allows access to the Wishbone address space.
BAR2 allows access to DDR address space and BAR0 is connected to the internal PCIe core registers.

The PCIe core is made of a Wishbone bus master mapped to BAR4 and a DMA controller mapped to BAR2.
The DMA controller reads/writes to the DDR controller through a direct AXI Stream interface.
The PCIe core Wishbone interfaces (masters and slave) are 32-bit data width and 64-bit word aligned addresses,
but the address is shifted right by 3 at the PCIe core. As all of the Wishbone register
space is BYTE aligned in this gateware, the user needs to increment the address by 0x4 in addition
of the 64-bit alignement requirement for each new register. @ref{tab:afc_pcie_core_address} shows
the addressing scheme for the Wishbone space.

@float Table,tab:afc_pcie_core_address
@include afc_pcie_core_address.txt
@caption{PCIe core address space scheme for Wishbone (BAR 4).}
@end float

As all of the modules are BYTE addressed, registers are effectively
separated by 0x4 in this scheme, so bit 2 onwards must be incremented
to access consecutive registers. This translates to an increment of:

  increment = 2^(3 (64-bit alignement) + 2 (byte address)) = 32 = 0x20

@b{Note:} It would not be beneficial to insert an address converter (for non-interleaved data read)
between the PCIe core and the memory controller, because the DDR memory access is not efficient when
reading non-consecutive addresses.

@c ==========================================================================

@section AFC Common Cores

@c --------------------------------------------------------------------------
@node DDR Memory Controller
@subsection DDR Memory Controller

The memory controller block is the interface between the 2GB DDR3 memory located
on the AFC carrier board and the other blocks in the FPGA.
It is basically a DDR3 Memory Interface Solution generated by Xilinx IP core@footnote{@uref{https://www.xilinx.com/support/documentation/ip_documentation/ug586_7Series_MIS.pdf}} with an AXI4 MM (Memory Mapped) interface.

The memory controller side connected to the chip is 32-bit wide, clocked at 800.00 MHz DDR.
This gives a maximum bandwidth of 6400.00 MB/s.
Each of the four ADC channels requires 200 MB/s (16-bits per sample, 100 MHz), for a total of 800 MB/s.
As we have 2 FMC per AFC, this gives a grand total of 1600 MB/s.

@c --------------------------------------------------------------------------
@node Vectored Interrupt Controller (VIC)
@subsection Vectored Interrupt Controller (VIC) (NOT USED IN THIS DESIGN)

In order to redirect interrupts from different cores to the corresponding driver in the Linux kernel in a generic way, a two layers scheme is used.
The first layer is the Embedded Interrupt Controllers (EIC) in each core multiplexing interrupt sources to a single line.
The second layer is the Vectored Interrupt Controller (VIC) multiplexing the interrupt lines from the EICs into a single line to the host.
The VIC keeps a table, initialized with the base addresses of the EICs connected to each of the input.

@b{Note:} On the AFC carrier, the VIC interrupt request output is not connected the PCIe core, hence not used.

The registers description can be found in annex @ref{Vectored Interrupt Controller}).

@c --------------------------------------------------------------------------
@node Acquisition Core Controller
@subsection Acquisition Core Controller

@c ==========================================================================
@node Acquisition Core Controller Trigger
@subsubsection Trigger

The trigger unit is made of two hardware and one software sources.
The hardware and software paths can be enabled independently.
The two paths are then or'ed together to drive a delay generator.
The delay generator allows to insert a predefined number of lock periods before the trigger is forwarded to the acquisition state machine.
@ref{fig:trig_unit} shows a simplified digram of the trigger unit.

@float Figure,fig:trig_unit
@center @image{../fig/trigger_unit, 12cm,,,pdf}
@caption{Trigger unit diagram.}
@end float

The hardware trigger source can be either internal (based on the data input
channels) or external (dedicated trigger input). The external trigger input is
managed by the Trigger Multiplexor Controller (@pxref{Trigger Multiplexor Controller}),
so that multiple trigger sources can feed signals to this acquisition module.

For both internal and external hardware triggers, the polarity can be selected between positive and negative slope (resp. rising and falling edge).
By default the polarity is set to positive slope.

The external trigger input is synchronised to the acquisition clock.
The external trigger pulse must be at least one acquisition clock cycle wide.

To use the internal trigger source, both the data input channel and the threshold should be configured.
By default, channel 1 is selected and the threshold is set to 0.
Note that the threshold is 32-bit signed (two's complement).
@ref{fig:trig_hw_int} sketches the internal hardware trigger threshold behavior.

@float Figure,fig:trig_hw_int
@center @image{../fig/trig_hw_int, 8cm,,,pdf}
@caption{Internal hardware trigger threshold.}
@end float

Furthermore, a glitch filter can be applied to the threshold detection.
The glitch filter is useful to trigger on noisy signals.

The software trigger source consists of a pulse generated when a write cycle is
detected on the @i{Software trigger} register. For further information on the
trigger configuration registers @pxref{Acquisition Core Registers}.

@c ==========================================================================
@node Acquisition Core Controller Modes
@subsubsection Acquisition Modes

This chapter describes the two modes of acquisition, single-shot and multi-shot.
It also explains how the software is expected to control the fmc-adc acquisitions.

@ref{fig:adc_core_sys_clk} shows the Acquisition core acquisition logic.
The heart of the acquisition logic is a state machine driven by user commands (start, stop), the trigger signal and counters events (e.g. pre-trig done, etc...).
The ADC samples are routed along a datapath (bold arrows), which depends on the acquisition mode.
It is explained in detail in the @ref{Acquisition Core Controller Single-shot Mode} and @ref{Acquisition Core Controller Multi-shot Mode}.
The data channels and the trigger are concatenated together and fed to a FIFO to be synchronised between the sampling clock domain and the system clock domain.
Along the datapath, we call @i{sample} the data channel width (in this case, a
64-bit vector containing a sample for each channel).
At the output of the ADC core, a flow control FIFO allows to cope with the
memory controller temporary unavailabilities (due to DDR refresh cycles) (FIXME
no trigger time-tag).

@float Figure,fig:adc_core_sys_clk
@center @image{../fig/adc_core_sys_clk, 15cm,,,pdf}
@caption{Acquisition logic diagram (system clock domain).}
@end float

Samples are stored interleaved in the DDR memory.
@ref{fig:mem_samples} illustrates the way samples are written, stored and read in the DDR memory.
The DDR memory size is 16Gb or 2GB.
@w{This means that the maximum number of samples that can be stored is 256M
(@math{2*2^{30} / 2*4}).}

@float Figure,fig:mem_samples
@center @image{../fig/memory_samples, 15cm,,,pdf}
@caption{Illustration of samples storage in DDR memory.}
@end float

The acquisition process is driven by a state machine.
@ref{fig:acq_fsm} represents its states and transitions.
At start-up (system reset), the state machine is @code{IDLE}, waiting for an acquisition start command (@code{ACQ_START}).
Commands are sent to the state machine by writing in the @code{FSM_CMD} field of the control register (@pxref{Acquisition Core Registers}).

When a start command is received, the state machine goes to @code{PRE_TRIG} and
stays in this state until the programmed number of pre-trigger samples are recorded.
After that, it goes in @code{WAIT_TRIG} state and continue recording sample to memory.

If the number of programmed pre-trigger samples is zero (only possible when in
triggered mode), the state machine skips the @code{PRE_TRIG} state and it goes
directly to @code{WAIT_TRIG}.

If the number of programmed post-trigger samples is zero (only possible when in
immediate mode, @code{fsm_acq_now} field in @code{Control Register}), the state
machine goes to the @code{PRE_TRIG} state and it skips @code{WAIT_TRIG} and
@code{POST_TRIG} states.

When a valid trigger is detected, the state machine moves to @code{POST_TRIG}.
It will stay in this state until the programmed number of post-trigger samples is reached.
When the trigger last @code{POST_TRIG} sample has been acquired, the state machine goes to @code{DECR_SHOT}.
From @code{DECR_SHOT} it either goes back to @code{IDLE} if the number of shots is reached or it repeats the same cycle for the next shot.

When the acquisition is finished (state machine back to @code{IDLE}) and all
samples have been written to the DDR memory, only then the software can retrieve
the samples using PIO or DMA transfer.

@b{Note:} At the moment no interrupt is generated when the acquisition ends.

@b{Note:} Start commands are taken into account only in @code{IDLE} state.

@b{Note:} Triggers are taken into account only in @code{WAIT_TRIG} state.

@b{Note:} A stop command will bring the state machine back to @code{IDLE} from any state.

@float Figure,fig:acq_fsm
@center @image{../fig/acq_fsm, 10cm,,,pdf}
@caption{Acquisition state machine (FIXME Immediate mode transition not shown)}
@end float

@b{Note:} The number of pre-trigger sample can be zero, but there @b{must} be at least one post-trigger sample.

@b{Note:} In addition to the requested pre/post-trigger samples, an additional sample, corresponding to the trigger, will be recorded.

@b{Note:} The start of an acquisition is prohibited if either the number of shots or the number of post-trigger samples is equal to zero.

@c ==========================================================================
@node Acquisition Core Controller Single-shot Mode
@subsubsection Single-shot Mode

The procedure below lists the different steps of a single-shot acquisition process.

@enumerate
@item Configure acquisition (trigger, number of samples, interrupts, etc...).
@item Issue a start acquisition command (the acquisition state machine must be @code{IDLE}).
@item Wait for the acquisition is completed (check acquisition state machine status.
@item Read trigger position register.
@item Configure the DMA or PIO to retrieve data.
@item Start the DMA transfer (the acquisition state machine must be @code{IDLE}).
@item Wait for DMA transfer to complete (check PCIe Core DMA status register).
@item The board is ready for a new acquisition start command.
@end enumerate

In single-shot mode, the DDR memory is used as a circular buffer.
When the acquisition starts, samples are directly written to the DDR memory (via FIFOs).
The acquisition logic stops writing to the memory when the configured number of pre/post-trigger samples is reached.
It could happen that the write pointer reaches the top of the memory before the end of the acquisition.
In this case, the write pointer is reset to address zero and overwrites previous samples.
In order to allow the software to retrieve the requested samples (around the trigger), the @i{Trigger address} register stores the write pointer address at the trigger moment.

@b{Note:} The value stored in the @i{Trigger address} register is a byte address.

@b{Note:} Every new acquisition starts writing at address configured at the @i{} (@pxref{Acquisition Core Registers}).

@ref{fig:mem_single_shot} and @ref{fig:mem_single_shot_overlap} illustrate the use of the DDR memory as a circular buffer.
The acquisition state machine is also represented.

@float Figure,fig:mem_single_shot
@center @image{../fig/memory_single-shot, 15cm,,,pdf}
@caption{Single-shot mode acquisition example.}
@end float

@float Figure,fig:mem_single_shot_overlap
@center @image{../fig/memory_single-shot_overlap, 15cm,,,pdf}
@caption{Single-shot mode acquisition example (overlapping DDR memory).}
@end float

@b{Note:} @i{Orange}: Samples written to memory and read back via DMA.
@i{Grey}: Samples written to memory, but not read.
@i{White}: Empty memory (or previous acquisition samples).


@c ==========================================================================
@node Acquisition Core Controller Multi-shot Mode
@subsubsection Multi-shot Mode

The multi-shot acquisition process is almost identical to the single-shot one, except that once the acquisition is started it will go around the state machine as many times as the number of configured shots.
This means that if the board is configured for N shots, it will generate N trigger interrupts (if enabled) and then another interrupt at the end of the acquisition.
A counter, accessible via a register, shows the remaining number of shots (@pxref{Acquisition Core Registers}).

Unlike the single-mode acquisition, in multi-shot, the DDR memory is not used as a circular buffer.
Instead, two dual port RAM (dpram) are implemented inside the FPGA.
Those dprams are alternatively used as circular buffer for each shot.
Even shots use dpram0 and odd shots dpram1.

When a shot is finished, the corresponding dpram samples are written to the DDR memory.
Only the pre-trigger samples and the post-trigger samples are written.
The first shot is written starting at address @code{0x0}.
Then the second shot is written right after the last post-trigger sample of the first shot.
@ref{fig:mem_multi_shot} shows the shots organisation in the DDR memory (FIXME
no trigger time-tag and trigger position samples).

@float Figure,fig:mem_multi_shot
@center @image{../fig/memory_multi-shot, 15cm,,,pdf}
@caption{DDR memory usage in multi-shot mode acquisition.}
@end float

@b{Note:} The number of samples per shot stored in memory is equal to: number of pre-trigger samples + number of post-trigger samples.

@b{Note:} In multi-shot mode, the start of an acquisition is prohibited if the number of sample per shot is bigger or equal to the dpram size.

@b{Note:} The size of the dprams is configurable during the generation of the
FPGA bitstream (VHDL generic), but not at runtime. The software can retrieve the
maximum @i{allowed} value from the @i{Multi-shot sample depth register}
(@pxref{Acquisition Core Registers}). The value stored in that read-only
register.

@c --------------------------------------------------------------------------
@node Trigger Interface Controller
@subsection Trigger Interface Controller

@c --------------------------------------------------------------------------
@node Trigger Multiplexor Controller
@subsection Trigger Multiplexor Controller


@c ==========================================================================

@section FMC-ADC Core

The ADC core is the main block of the design.
On the mezzanine interface side, it takes a data flow from the LTC2174 ADC chip,
an external trigger and controls the analogue switches to select the input range or calibration mode.
On the internal interface side, it has a plain streaming interface to write data to the DDR memory controller,
through the Acquisition core.
It also has a Wishbone slave to access the internal components.

The internal detailed functioning of this block is described further in the document
(@xref{Configuration}, @ref{Calibration} and @ref{Acquisition Core Controller}).

@c --------------------------------------------------------------------------
@subsection Front Panel LEDS

There are two LEDs on the fmc-adc front panel. They are currently not being used
in this version of the gateaware.

@c --------------------------------------------------------------------------
@subsection Sampling clock

The sampling frequency is determined by a Si570 programmable oscillator located on the fmc-adc mezzanine.
By default, the sampling clock is 100MHz (oscillator factory default value), but it can be changed to any frequency from 10MHz to 105MHz. The lower bound is defined by the Si570 oscillator while the upper bound is limited by the LTC2174 ADC itself.

The Si570 clock output is connected to the LTC2174 ADC.
Then the data clock (DCO) output of the LTC2174 is connected to the FPGA.
The data clock is four times the sampling clock.
The sampling clock (@code{fs_clk}) and the ADC data de-serialiser clock (@code{serdes_clk}) are derived from the data clock using a PLL (internal to the FPGA).

Although the internal PLL expects a 400MHz input frequency (defined in the hdl code), it should
be possible to adjust the sampling frequency dynamically as the FPGA PLL has a wide lock frequency range.

It's possible to change the sampling frequency via the mezzannine I2C of both
FMC1 or FMC2, by setting the corresponding registers in @code{WB-I2C-Master}
under the desided FMC address space (@pxref{tab:afc_memory_map}).

The ADC core implements a sampling clock frequency meter.
The measured frequency (in Hz) can be read via a register (@pxref{ADC Core Registers}).

@c --------------------------------------------------------------------------
@subsection Time-tagging Core (NOT USED IN THIS DESIGN)

This block allows time-tagging of important events in the ADC core.
It is based on two free-running counters;
a seconds counter and a 125MHz system clock ticks counter.
The system clock ticks counter is also called coarse counter.
These two counters are accessible in read/write via a Wishbone interface.

For example, the host computer can use the OS time to set the seconds counter and simply reset the coarse counter.
It is planned, in a later release, to set the time-tagging core counters using the White Rabbit core.

A time-tag is made of four 32-bit words; meta-data, seconds, coarse, fine.
The fine field is always set to zero and the meta-data register does not contain useful information, only random data for debugging purposes.

The register description can be found in annex @ref{Time-tagging Core Registers}.

@c --------------------------------------------------------------------------

@subsection FMC-ADC Control and Status Registers

This block contains control and status registers related to the fmc-adc core.
The registers description can be found in annex (@ref{ADC Core Registers}).

@c --------------------------------------------------------------------------
@subsection Mezzanine SPI Master

This SPI master controls the LTC2174 ADC@footnote{@uref{http://cds.linear.com/docs/en/datasheet/21754314fa.pdf}} and the four MAX5442 offset DACs@footnote{@uref{http://datasheets.maximintegrated.com/en/ds/MAX5441-MAX5444.pdf}}.
The following table shows how the peripherals are wired to the core.
This block is based on an OpenCores design@footnote{@uref{http://opencores.org/project@comma{}spi}}.
@c FIXME broken @comma{} to generate url link (prints 'comma{}' instead of ',')


@multitable @columnfractions .20 .35
@headitem SPI slave select @tab Peripheral
@item @code{0} @tab LTC2174 ADC
@item @code{1} @tab MAX5442 DAC for channel 1
@item @code{2} @tab MAX5442 DAC for channel 2
@item @code{3} @tab MAX5442 DAC for channel 3
@item @code{4} @tab MAX5442 DAC for channel 4
@end multitable
@sp 1

This block is clocked by the system clock (125 MHz).
Therefore for a SCLK of ~620 kHz, the divider configuration is @code{DIVIDER=100}.

@example
@group
f_sclk = f_sys / ((DIVIDER+1) * 2)
@end group
@end example

@c --------------------------------------------------------------------------
@subsection Mezzanine 1-wire Master

This 1-wire master controls the DS18B20 thermometer chip located on the mezzanine board.
This chip also contains a unique 64-bit identifier.
This block is based on an OpenCores design@footnote{@uref{http://opencores.org/project@comma{}sockit_owm}}.
@c FIXME broken @comma{} to generate url link (prints 'comma{}' instead of ',')

This block is clocked by the system clock (125 MHz).
Therefore the dividers configuration are @code{CDR_N=624} and @code{CDR_O=124}.

@example
@group
CDR_N = f_sys * 5 us - 1
CDR_O = f_sys * 1 us - 1
@end group
@end example

@c --------------------------------------------------------------------------
@subsection Mezzanine I2C Master

This I2C master controls the Si570 programmable oscillator chip@footnote{@uref{https://www.silabs.com/Support%20Documents/TechnicalDocs/si570.pdf}} located on the mezzanine board.
This chip is used to produce the ADC sampling clock.
This block is based on an OpenCores design@footnote{@uref{http://opencores.org/project@comma{}i2c}}.
@c FIXME broken @comma{} to generate url link (prints 'comma{}' instead of ',')

@multitable @columnfractions .20 .50
@headitem I2C slave address @tab Peripheral
@item @code{0x55} @tab Si570 programmable oscillator
@end multitable
@sp 1

This block is clocked by the system clock (125 MHz).
Therefore for a SCL clock of 100 kHz, the prescaler configuration is @code{PRESCALER=249}.

@example
@group
PRESCALER = f_sys / (5 * f_scl) - 1
@end group
@end example

@c --------------------------------------------------------------------------
@subsection Mezzanine System Management I2C Master

This I2C master accesses the 24AA64 64Kb EEPROM memory chip@footnote{@uref{http://ww1.microchip.com/downloads/en/devicedoc/21189f.pdf}} located on the mezzanine board.
This memory is mandatory as specified in the FMC standard (VITA 57.1). It is connected to the system management I2C bus, also specified in the FMC standard.
This block is based on an OpenCores design@footnote{@uref{http://opencores.org/project@comma{}i2c}}.
@c FIXME broken @comma{} to generate url link (prints 'comma{}' instead of ',')

@multitable @columnfractions .20 .50
@headitem I2C slave address @tab Peripheral
@item @code{0x50} @tab 24AA64 64Kb EEPROM memory
@end multitable
@sp 1

This block is clocked by the system clock (125 MHz).
Therefore for a SCL clock of 100 kHz, the prescaler configuration is @code{PRESCALER=249}.

@example
@group
PRESCALER = f_sys / (5 * f_scl) - 1
@end group
@end example


@c --------------------------------------------------------------------------
@subsection FMC-ADC Embedded Interrupt Controller (EIC) (NOT USED IN THIS DESIGN)

The fmc-adc EIC gathers the interrupts from other modules inside the gateware

The inputs are multiplexed and the result is forwarded to the VIC (@ref{Vectored Interrupt Controller (VIC)}).
Interrupt sources can be masked using the enable and disable registers.
An interrupt is cleared by writing a one to the corresponding bit of the status register.

The registers description can be found in annex @ref{FMC-ADC Embedded Interrupt Controller Registers}).

@c ##########################################################################
@page
@node Configuration
@chapter Configuration

@ref{fig:adc_core_fs_clk} is a block diagram of the ADC core part in the sampling clock domain. It contains an ADC data stream de-serialiser, an offset and gain correction block (for ADC data), an under-sampling block and a trigger unit.
The four channels' data and the trigger signal are synchronised to the system clock domain using a FIFO.
The configuration signals coming from registers in the system clock domain are synchronised to the sampling clock within the Wishbone slave (@command{wbgen2} feature).

@float Figure,fig:adc_core_fs_clk
@center @image{../fig/adc_core_fs_clk, 14cm,,,pdf}
@caption{ADC core diagram (sampling clock domain).}
@end float

The LTC2174 is by default configured in @i{2-Lane Output Mode, 16-Bit Serialization}.
In the fmc-adc application, this default configuration is kept.
@ref{fig:ltc2174_mode} is an extract from the LTC2174 datasheet illustrating the @i{2-Lane Output Mode, 16-Bit Serialization} waveforms.

@float Figure,fig:ltc2174_mode
@center @image{../fig/ltc2174_mode, 12cm,,,pdf}
@caption{LTC2174 data output mode waveforms.}
@end float

There are two 800Mbit/s lanes per ADC channel.
Eight data lanes in total and the frame rate (FR) lane are fed to a de-serialiser in the FPGA.
The frame rate signal is used to align the de-serialiser to data words.
The four channel data (16-bit) are concatenated together to form a 64-bit vector.
As shown in @ref{fig:ltc2174_mode}, the two LSB bits of a data word are always set to zero.

@strong{Important:} Upon reset the ADC defaults to ``offset binary''
representation for the channel data. However, the ADC core expects
``two's complement''. Therefore, it is important to change the
relevant configuration register in the ADC itself.

@c ==========================================================================
@section Control and Status Registers

Writing one to to the @code{FMC_CLK_OE} field of the ADC core control register enables the sampling clock (Si570 chip).
Also, in order to use the input offset DACs, the @code{OFFSET_DAC_CLR_N} field must be set to one.

The field @code{MAN_BITSLIP} allows to 'manually' control the ADC data alignment in the de-serialiser.
When @code{TEST_DATA_EN} is set, the ADC core writes the address pointer to the memory instead of the ADC samples.
The fields @code{TRIG_LED} and @code{ACQ_LED} allows to control the FMC front panel LEDs.
Those four fields are for test purpose only and must stay zero in normal operation.

When the sampling clock is enabled, the @code{SERDES_PLL} and @code{SERDES_SYNCED} field from the ADC core status register must be set to one.

@c ==========================================================================
@section Input Ranges

@ref{fig:analogue_input} shows a simplified schematic diagram of the analogue input stage used for each channel.
Each input can be independently configured with one of the three available ranges; 100mV, 1V, 10V.
Each range is defined as the maximum peak-to-peak input voltage.
Independently to the selected range, a 50ohms termination can be added to each input.

In addition to the three ranges for normal operation, there are three more configurations used for offset calibration of each range.

Opto-isolated analogue switches are used to apply the various configurations. They are represented by standard switch symbols in the simplified schematic.

@float Figure,fig:analogue_input
@center @image{../fig/analogue_input, 10cm,,,pdf}
@caption{Simplified schematic diagram of the analogue input stage.}
@end float

Only the following input switch configurations are valid.
For all others switch configurations, the behavior is not defined and therefore shouldn't be used.

@float Table,tab:switch_config
@multitable {SW[7..1]}{SW7}{SW6}{SW5}{SW4}{SW3}{SW2}{SW1}{100mV range offset calibration}
@headitem SW[7..1] @tab SW7 @tab SW6 @tab SW5 @tab SW4 @tab SW3 @tab SW2 @tab SW1 @tab Description
@item @code{0x23} @tab @code{OFF} @tab @code{ON}  @tab @code{OFF} @tab @code{X}   @tab @code{OFF} @tab @code{ON}  @tab @code{ON}  @tab 100mV range
@item @code{0x11} @tab @code{OFF} @tab @code{OFF} @tab @code{ON}  @tab @code{X}   @tab @code{OFF} @tab @code{OFF} @tab @code{ON}  @tab 1V range
@item @code{0x45} @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{ON}  @tab @code{OFF} @tab @code{ON}  @tab 10V range
@item @code{0x42} @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{OFF} @tab @code{ON}  @tab @code{OFF} @tab 100mV range offset calibration
@item @code{0x40} @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{OFF} @tab @code{OFF}  @tab @code{OFF}  @tab 1V range offset calibration
@item @code{0x44} @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{ON}  @tab @code{OFF} @tab @code{OFF} @tab 10V range offset calibration
@item @code{0x00} @tab @code{X}   @tab @code{OFF} @tab @code{OFF} @tab @code{OFF} @tab @code{X}   @tab @code{X}   @tab @code{OFF} @tab Input disconnected
@item @code{0x08} @tab @code{X}   @tab @code{X}   @tab @code{X}   @tab @code{ON}  @tab @code{X}   @tab @code{X}   @tab @code{X}   @tab 50ohm termination
@end multitable
@caption{Analogue input switches configurations.}
@end float

@c ==========================================================================
@section Input Offset

Each channel has a 16-bit DAC allowing to apply a dc offset to the input signal.
The voltage range of the DAC is 10V (-5V to +5V) and is independent from the selected input range.
The following equation shows how to convert a digital value written to a DAC to an offset voltage.

@example
@group
v_dac = (v_ref * d_dac/0x8000) - v_ref
Where:
v_ref = DAC's voltage reference = 5V
d_dac = Digital value written to the DAC
v_dac = DAC voltage

Example:
0xFFFF =>  4.999V
0x8000 =>  0.000V
0x0000 => -5.000V
@end group
@end example

The following equation shows the relation between the input voltage and the offset (applied by the DAC).
Note that the offset from the DAC is subtracted from the input voltage.

@example
@group
v_out = v_in - v_dac
Where:
v_in  = Input voltage
v_dac = DAC voltage
v_out = Output voltage (to filter and ADC)
@end group
@end example

@c ==========================================================================
@section Undersampling

The undersampling block is simply validating one in N samples and forwarding it to the acquisition logic.
The number (N) is configured in the @i{Sample rate} register.
If N > 1, then the trigger pulse is aligned to the next valid sample.
If N = 1 all the samples are valid and therefore the trigger is always aligned.
A value of N = 0 is treated as N = 1 in the gateware.

@c ##########################################################################
@page
@node Calibration
@chapter Calibration

Calibration is done once during the production tests.
It can be repeated afterwards with the production test suite (PTS) and the corresponding testbench.
The calibration process gives the following four values per channel and per input range:
@itemize @textdegree
@item ADC gain correction
@item ADC offset correction
@item DAC gain correction
@item DAC offset correction
@end itemize

Note that the temperature during the calibration process is also measured.
This could be used for later temperature compensated calibration value computing.

@c ==========================================================================
@section Calibration data storage
All the calibration values are stored in the FmcAdc100m14b4cha EEPROM.
The EEPROM holds an sdbfs@footnote{@uref{http://www.ohwr.org/attachments/download/1594/sdbfs-2012-09-19.pdf}} file system.
In addition to the calibration values, the EEPROM also contains mandatory IPMI@footnote{Platform Management FRU Information Storage Definition v1.0} records specified in the FMC Standard VITA 57.1 (see table @ref{tab:eeprom_sdbfs} for mapping).

@float Table,tab:eeprom_sdbfs
@multitable @columnfractions .12 .18 .15 .30
@headitem Byte offset @tab File name @tab File Type @tab Description
@item @code{0x0}    @tab IPMI-FRU        @tab binary @tab IPMI records
@item @code{0x100}  @tab calib           @tab binary @tab Calibration values
@item @code{auto}   @tab name            @tab ascii  @tab Contains "adc_100m"
@item @code{0x800}  @tab data            @tab binary @tab Empty directory
@item @code{0x200}  @tab .               @tab binary @tab Root directory
@item               @tab                 @tab        @tab vendor = 0xCE42
@item               @tab                 @tab        @tab device = 0xC5BE045E
@end multitable
@caption{EEPROM sdb file system.}
@end float

Note that the vendor value 0xCE42 corresponds to CERN. While the device value 0xC5BE045E corresponds to the first 32-bit of the md5 sum of "fmc-adc-100m14b4cha".

@c ==========================================================================
@section Calibration Data Usage

@subsection ADC Calibration
Two registers per channel are implemented in the FPGA for ADC gain and offset correction.
When an input range is selected, the corresponding gain/offset correction values must be loaded from the EEPROM to those registers.

@float Figure,fig:off_gain_corr
@center @image{../fig/offset_gain_corr, 12cm,,,pdf}
@caption{ADC offset and gain correction block.}
@end float

The offset register takes a 16-bit signed value.
The gain register takes a 16-bit fixed point value.
The fixed point format is as follow:

@float Figure,fig:adc_gain_format
@center @image{../fig/adc_gain_format, 13cm,,,pdf}
@caption{ADC gain register format.}
@end float

After the offset and gain corrections are applied, the signal is saturated to a user-programmable value.
One register per channel allows to set the saturation value.
The saturation register takes a 15-bit unsigned value.
From this value, two 'symmetrical' 16-bit signed numbers are derived and taken as the saturation boundaries.

@b{Note:} Because the default value (on FPGA start-up) is not configurable in wbgen2, the gain, offset and saturation registers are set to 0x0 at start-up.
Therefore, the driver has to initialise those registers.

@b{Note:} After gain and offset correction, the two LSB of the data words can be different from zero.

@b{Note:} It is usually the driver's task to read the calibration data from the FMC EEPROM and load them to the corresponding registers. This has to be done once at start-up and then every time the input range is changed.


@subsection DAC Calibration

The DAC value is only set once before an acquisition.
Therefore, there is no need to implement the gain and offset correction in the FPGA.
The software controlling the fmc-adc must apply the DAC gain and offset correction prior to writing a value to the DAC.
As for the ADC correction values, there is one pair (offset, gain) of DAC correction values per input range.

Below is the formula to calculate the corrected DAC value (applying gain and offset correction):
@example
@group
c_val = ((val + offset) * gain/0x8000) + 0x8000
where:
c_val  = corrected value to write to DAC (16-bit unsigned)
val    = value from user (16-bit signed)
offset = DAC offset calibration value from EEPROM (16-bit signed)
gain   = DAC gain calibration value from EEPROM (16-bit fixed point)
@end group
@end example


@c --------------------------------------------------------------------------
@c macro to allow includes from wbgen2 generated tex register documentation
@macro regsection{name}
@section \name\
@end macro

@c --------------------------------------------------------------------------
@page
@appendix ADC Core Registers
The registers documentation have been generated using @command{wbgen2}@footnote{@uref{http://www.ohwr.org/projects/wishbone-gen}}.
@anchor{ADC Core Registers}
   @include fmc_adc_100Ms_csr.tex

@c --------------------------------------------------------------------------
@page
@appendix FMC-ADC Embedded Interrupt Controller Registers
The registers documentation have been generated using @command{wbgen2}@footnote{@uref{http://www.ohwr.org/projects/wishbone-gen}}.
@anchor{FMC-ADC Embedded Interrupt Controller Registers}
   @include fmc_adc_eic.tex

@c --------------------------------------------------------------------------
@page
@appendix Vectored Interrupt Controller
The registers documentation have been generated using @command{wbgen2}@footnote{@uref{http://www.ohwr.org/projects/wishbone-gen}}.
@anchor{Vectored Interrupt Controller}
   @include wb_vic.tex

@c --------------------------------------------------------------------------
@page
@appendix Time-tagging Core Registers
The registers documentation have been generated using @command{wbgen2}@footnote{@uref{http://www.ohwr.org/projects/wishbone-gen}}.
@anchor{Time-tagging Core Registers}
   @include timetag_core_regs.tex

@c --------------------------------------------------------------------------
@page
@appendix ADC Management Registers
The registers documentation have been generated using @command{wbgen2}@footnote{@uref{http://www.ohwr.org/projects/wishbone-gen}}.
@anchor{ADC Management Registers}
   @include afc_mgmt_regs_wb.tex

@c --------------------------------------------------------------------------
@page
@appendix Acquisition Core Registers
The registers documentation have been generated using @command{wbgen2}@footnote{@uref{http://www.ohwr.org/projects/wishbone-gen}}.
@anchor{Acquisition Core Registers}
   @include wb_acq_core.tex

@c --------------------------------------------------------------------------
@page
@appendix MicroTCA.4 MLVDS Trigger Interface Registers
The registers documentation have been generated using @command{wbgen2}@footnote{@uref{http://www.ohwr.org/projects/wishbone-gen}}.
@anchor{MicroTCA.4 MLVDS Trigger Interface Registers}
   @include wb_trigger_iface_regs_wb.tex

@c --------------------------------------------------------------------------
@page
@appendix Trigger Multiplexor Registers
The registers documentation have been generated using @command{wbgen2}@footnote{@uref{http://www.ohwr.org/projects/wishbone-gen}}.
@anchor{Trigger Multiplexor Registers}
   @include wb_trigger_mux_regs_wb.tex

@c --------------------------------------------------------------------------
@page
@appendix Glossary
@section Glossary

@table @b
@item Pulse
      In this document, a @b{pulse} refers to a one clock tick wide pulse.
@item Tick
      A clock @b{tick} corresponds to a period of the clock.
@item SDB
      Self-Describing Bus
@item VIC
      Vectored Interrupt Controller
@item EIC
      Embedded Interrupt Controller
@end table



@bye
